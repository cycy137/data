[
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/29",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/29/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/29/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/29/events",
    "html_url": "https://github.com/axuebin/articles/issues/29",
    "id": 405107346,
    "node_id": "MDU6SXNzdWU0MDUxMDczNDY=",
    "number": 29,
    "title": "ES2019",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "node_id": "MDQ6VXNlcjEzMzE2Mzky",
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720884127,
        "node_id": "MDU6TGFiZWw3MjA4ODQxMjc=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720882955,
        "node_id": "MDU6TGFiZWw3MjA4ODI5NTU=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 720884524,
        "node_id": "MDU6TGFiZWw3MjA4ODQ1MjQ=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%89%8D%E7%AB%AF",
        "name": "前端",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-01-31T06:58:55Z",
    "updated_at": "2019-01-31T07:02:37Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "## ES2019\r\n\r\n[tc39 Finished Proposals](https://github.com/tc39/proposals/blob/master/finished-proposals.md)\r\n\r\n![ES2019](https://raw.githubusercontent.com/axuebin/articles/master/images/es-finished-proposals.png)\r\n\r\n从表中可以看到已经有多个特性加到了 ES2019 中。\r\n\r\n## 新特性\r\n\r\n### Optional catch binding\r\n\r\n[https://github.com/tc39/proposal-optional-catch-binding](https://github.com/tc39/proposal-optional-catch-binding)\r\n\r\n将 `err` 变成 `optional` 的，可以省略 `catch` 后的 括号和错误对象：\r\n\r\n```javascript\r\ntry {\r\n  // tryCode\r\n} catch {\r\n  // catchCode\r\n}\r\n```\r\n\r\n#### Previous\r\n\r\n之前 `try...catch` 是这样的：\r\n\r\n```javascript\r\ntry {\r\n  // tryCode\r\n} catch(err) {\r\n  // catchCode\r\n}\r\n```\r\n\r\n- tryCode：（必须）尝试执行的代码\r\n- err：（必须）指定局部变量应用的错误\r\n- catchCode：（可选）捕获错误的代码\r\n\r\n比如：\r\n\r\n```javascript\r\ntry {\r\n  throw new Error('报错啦报错啦');\r\n} catch(e) {\r\n  console.log(e); // Error: 报错啦报错啦\r\n}\r\n```\r\n\r\n有的时候我们只需要捕获错误但是无需知道错误信息，`err` 就显得没必要的。\r\n\r\n### JSON superset\r\n\r\n[https://github.com/tc39/proposal-json-superset](https://github.com/tc39/proposal-json-superset)\r\n\r\n\r\n允许 未转义的 `U + 2028` 行分隔符和 `U + 2029` 段分割符直接出现在字符串中，不会出现异常。\r\n\r\n#### Previous\r\n\r\n之前，JSON的某些字符 `\\u2028` `\\u2029` 会导致 Javascript 语法错误。\r\n\r\n```javascript\r\neval('\"\\u2028\"'); // SyntaxError: Unexpected\r\n```\r\n\r\n我们的解决方法是对 `\\u2028` `\\u2029` 进行转义，比如：\r\n\r\n```javascript\r\nstr.Replace('\\u2028', '\\\\u2028')\r\n```\r\n\r\n### Symbol.prototype.description\r\n\r\n[https://github.com/tc39/proposal-Symbol-description](https://github.com/tc39/proposal-Symbol-description)\r\n\r\n[Symbol.prototype.description | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/description)\r\n\r\n可以通过 `description` 方法获取 `Symbol` 的描述:\r\n\r\n```javascript\r\nconst name = Symbol('My name is axuebin');\r\nconsole.log(name.description); // My name is axuebin\r\nconsole.log(name.description === 'My name is axuebin'); // My name is axuebin\r\n```\r\n\r\n#### Previous\r\n\r\n我们知道，`Symbol` 的描述只被存储在内部的 `[[Description]]`，没有直接对外暴露，我们只有调用 `Symbol` 的 `toString()` 时才可以读取这个属性：\r\n\r\n```javascript\r\nconst name = Symbol('My name is axuebin');\r\nconsole.log(name.toString()); // Symbol(My name is axuebin)\r\nconsole.log(name); // Symbol(My name is axuebin)\r\nconsole.log(name === 'Symbol(My name is axuebin)'); // false\r\nconsole.log(name.toString()) === 'Symbol(My name is axuebin)'); // true\r\n\r\n```\r\n\r\n在执行 `console.log(name)` 的时候也打印了描述信息，是因为这里隐式地执行了 `toString()`，在代码里这样是不行的。\r\n\r\n### Function.prototype.toString revision\r\n\r\n[https://github.com/tc39/Function-prototype-toString-revision](https://github.com/tc39/Function-prototype-toString-revision)\r\n\r\n现在 `foo.toString()` 可以返回精确字符串，包括空格和注释等。\r\n\r\n### Object.fromEntries\r\n\r\n[https://github.com/tc39/proposal-object-from-entries](https://github.com/tc39/proposal-object-from-entries)\r\n\r\n[Object.fromEntries() | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)\r\n\r\n该方法把键值对列表转换为一个对象，可以看作是 `Object.entries()` 的反向方法。\r\n\r\n- Arguments：(Array): 键值对。\r\n- Returns：(Object): 对象。\r\n\r\n\r\n```javascript\r\nconst arr = Object.entries({ name: 'axuebin', age: 27 });\r\nconsole.log(arr); // [\"name\", \"axuebin\"], [\"age', 27]]\r\n\r\nconst obj = Object.fromEntries(arr);\r\nconsole.log(obj); // { name: 'axuebin', age: 27 }\r\n```\r\n\r\n和 `lodash` 的 `_.fromPairs` 具有一样的功能。\r\n\r\n```javascript\r\nconst obj = _.fromPairs(['name', 'axuebin'], ['age', 27]);\r\nconsole.log(obj); // { name: 'axuebin', age: 27 }\r\n```\r\n\r\n### Well-formed JSON.stringify\r\n\r\n[https://github.com/tc39/proposal-well-formed-stringify](https://github.com/tc39/proposal-well-formed-stringify)\r\n\r\n更友好的 `JSON.stringify`，对于一些超出范围的 `Unicode`，为其输出转义序列，使其成为有效 `Unicode`，\r\n\r\n```javascript\r\nJSON.stringify('\\uDF06\\uD834'); // '\"\\\\udf06\\\\ud834\"'\r\nJSON.stringify('\\uDEAD'); // '\"\\\\udead\"'\r\n```\r\n\r\n#### Previous\r\n\r\n```javascript\r\nJSON.stringify('\\uDF06\\uD834'); // '\"��\"'\r\nJSON.stringify('\\uDEAD'); // '\"�\"'\r\n```\r\n\r\n### String.prototype.{trimStart,trimEnd}\r\n\r\n[https://github.com/tc39/proposal-string-left-right-trim](https://github.com/tc39/proposal-string-left-right-trim)\r\n\r\n[String.prototype.trimStart() | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trimStart)\r\n\r\n[String.prototype.trimEnd() | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trimEnd)\r\n\r\n分别去除字符串前后的空格，生成新的字符串。\r\n\r\n```javascript\r\nconst str = '    axuebin    ';\r\nconsole.log(str.trimStart()); // 'axuebin    '\r\nconsole.log(str.trimEnd()); // '    axuebin'\r\nconsole.log(str); // '    axuebin    '\r\n```\r\n\r\n### Array.prototype.{flat,flatMap}\r\n\r\n[https://github.com/tc39/proposal-flatMap](https://github.com/tc39/proposal-flatMap)\r\n\r\n[Array.prototype.flat() | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)\r\n\r\n[Array.prototype.flatMap() | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap)\r\n\r\n还记得这样一道笔试题么，给你一个多维数组，把它拍平！\r\n\r\n```javascript\r\nconst arr = [1, [2, [3, [4, [5, 6]]]]];\r\narr.flat(); // [1, 2, [3, [4, [5, 6]]]]\r\narr.flat(1); // [1, 2, [3, [4, [5, 6]]]]\r\narr.flat(2); // [1, 2, 3, [4, [5, 6]]]\r\narr.flat(3); // [1, 2, 3, 4, [5, 6]]\r\narr.flat(4); // [1, 2, 3, 4, 5, 6]\r\n```\r\n\r\n```javascript\r\nconst arr = [[1, 2, 3], [4, 5]];\r\narr.flatMap(item => item); [1, 2, 3, 4, 5];\r\n```\r\n\r\n是不是很方便...\r\n\r\n## 暂时就这些啦"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/28",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/28/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/28/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/28/events",
    "html_url": "https://github.com/axuebin/articles/issues/28",
    "id": 402983109,
    "node_id": "MDU6SXNzdWU0MDI5ODMxMDk=",
    "number": 28,
    "title": "JavaScript 判断 iPhone X Series 机型",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "node_id": "MDQ6VXNlcjEzMzE2Mzky",
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720883997,
        "node_id": "MDU6TGFiZWw3MjA4ODM5OTc=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/ES6",
        "name": "ES6",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884127,
        "node_id": "MDU6TGFiZWw3MjA4ODQxMjc=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720882955,
        "node_id": "MDU6TGFiZWw3MjA4ODI5NTU=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 720884524,
        "node_id": "MDU6TGFiZWw3MjA4ODQ1MjQ=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%89%8D%E7%AB%AF",
        "name": "前端",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2019-01-25T02:48:54Z",
    "updated_at": "2019-01-26T03:29:52Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "## 现状\r\n\r\niPhone X 底部是需要预留 34px 的安全距离，需要在代码中进行兼容。\r\n\r\n现状对于 iPhone X 的判断基本是这样的：\r\n\r\n```javascript\r\n// h5\r\nexport const isIphonex = () => /iphone/gi.test(navigator.userAgent) && window.screen && (window.screen.height === 812 && window.screen.width === 375);\r\n```\r\n\r\n这在之前是没问题的，新的 iPhone X Series 设备发布之后，这个就会兼容就有问题。\r\n\r\n## iPhone X Series 参数\r\n\r\n| 机型 | 倍率\t| 分辨率 |\tpt |\r\n| :--- | :--- | :--- | :--- |\r\n| iPhone X |\t3 | 2436 × 1125 | 812 × 375 |\r\n| iPhone XS | 3 | 2436 × 1125 | 812 × 375 |\r\n| iPhone XS Max | 3\t| 2688 × 1242\t | 896 × 414 |\r\n| iPhone XR | 2 | 1792 × 828 | 896 × 414 |\r\n\r\nwidth === 375 && height === 812 只能识别出 iPhone X 和 iPhone XS，对于 iPhone XS Max 和 iPhone XR 就无能为力了。\r\n\r\n## 解决方法\r\n\r\n### 对每个机型进行判断\r\n```javascript\r\nconst isIphonex = () => {\r\n  // X XS, XS Max, XR\r\n  const xSeriesConfig = [\r\n    {\r\n      devicePixelRatio: 3,\r\n      width: 375,\r\n      height: 812,\r\n    },\r\n    {\r\n      devicePixelRatio: 3,\r\n      width: 414,\r\n      height: 896,\r\n    },\r\n    {\r\n      devicePixelRatio: 2,\r\n      width: 414,\r\n      height: 896,\r\n    },\r\n  ];\r\n  // h5\r\n  if (typeof window !== 'undefined' && window) {\r\n    const isIOS = /iphone/gi.test(window.navigator.userAgent);\r\n    if (!isIOS) return false;\r\n    const { devicePixelRatio, screen } = window;\r\n    const { width, height } = screen;\r\n    return xSeriesConfig.some(item => item.devicePixelRatio === devicePixelRatio && item.width === width && item.height === height);\r\n  }\r\n  return false;\r\n}\r\n```\r\n### 统一处理方法\r\n因为现在 iPhone 在 iPhone X 之后的机型都需要适配，所以可以对 X 以后的机型统一处理，我们可以认为这系列手机的特征是 `ios` + `长脸`。\r\n\r\n在 H5 上可以简单处理。\r\n\r\n```javascript\r\nconst isIphonex = () => {\r\n  if (typeof window !== 'undefined' && window) {\r\n    return /iphone/gi.test(window.navigator.userAgent) && window.screen.height >= 812;\r\n  }\r\n  return false;\r\n};\r\n```\r\n\r\n### 媒体查询\r\n\r\n```css\r\n@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) {\r\n}\r\n@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) {\r\n}\r\n@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) {\r\n}\r\n```\r\n\r\n媒体查询无法识别是不是 iOS，还得加一层 JS 判断，否则可能会误判一些安卓机。"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/27",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/27/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/27/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/27/events",
    "html_url": "https://github.com/axuebin/articles/issues/27",
    "id": 343559845,
    "node_id": "MDU6SXNzdWUzNDM1NTk4NDU=",
    "number": 27,
    "title": "滚动防抖引发的一个莫名其妙的bug",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "node_id": "MDQ6VXNlcjEzMzE2Mzky",
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720884127,
        "node_id": "MDU6TGFiZWw3MjA4ODQxMjc=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720882955,
        "node_id": "MDU6TGFiZWw3MjA4ODI5NTU=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 720881363,
        "node_id": "MDU6TGFiZWw3MjA4ODEzNjM=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/bug",
        "name": "bug",
        "color": "ee0701",
        "default": true
      },
      {
        "id": 720881366,
        "node_id": "MDU6TGFiZWw3MjA4ODEzNjY=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/help%20wanted",
        "name": "help wanted",
        "color": "33aa3f",
        "default": true
      },
      {
        "id": 720881369,
        "node_id": "MDU6TGFiZWw3MjA4ODEzNjk=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/question",
        "name": "question",
        "color": "cc317c",
        "default": true
      },
      {
        "id": 720884524,
        "node_id": "MDU6TGFiZWw3MjA4ODQ1MjQ=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%89%8D%E7%AB%AF",
        "name": "前端",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2018-07-23T09:40:46Z",
    "updated_at": "2018-07-23T09:40:46Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "### 问题描述\r\n\r\n一开始这个 `bug` 是在 `weex` 下遇到的，使用的是 `weex` 自己的 `scroller` 组件，需要对滑动操作做防抖，会出现3s左右的延迟。\r\n\r\n![image](https://user-images.githubusercontent.com/13316392/43068494-1bb783de-8e9d-11e8-8950-d68cbc0e3a91.png)\r\n![image](https://user-images.githubusercontent.com/13316392/43068502-219d53fa-8e9d-11e8-9dbc-e996bf43cf90.png)\r\n![image](https://user-images.githubusercontent.com/13316392/43068502-219d53fa-8e9d-11e8-9dbc-e996bf43cf90.png)\r\n\r\n### 问题定位\r\n\r\n做了几个组合实验来排除可能性：\r\n\r\n1. `weex` 滚动组件 `@scroll+setTimeout`（会出现）\r\n2. `div@scroll.native+setTimeout`（单独测试不会出现，项目中会出现）\r\n3. `weex` 滚动组件 `@scroll.native+setTimeout`（会出现）\r\n\r\n剥离业务代码后的代码如下：\r\n\r\n```javascript\r\nlet timeout = 0;\r\nlet time = '';\r\nexport default {\r\n    methods: {\r\n        onScroll() {\r\n            time = Date.now();\r\n            console.log('滚动', time);\r\n            clearTimeout(timeout);\r\n            timeout = setTimeout(() => {\r\n                time = Date.now();\r\n                console.log('触发', time);\r\n            }, 1000);\r\n        },\r\n    },\r\n};\r\n```\r\n\r\n`setTimeout(() => {}, delay)`  中 `delay` 设置超过3s就是正常设置的时间，如果设置的 `delay` 小于3s，就会出现3s延迟。\r\n\r\n`setTimeout(() => {}, 0)` 也会出现这个问题，`setImmediate()` 不会出现这个问题，但是就不起防抖的作用。\r\n\r\n然而没有找出问题所在。。。\r\n\r\n### 解决方法\r\n\r\n暂时使用 `requestAnimationFrame` 替代 `setTimeout`。\r\n\r\n```javascript\r\nsetRaf() {\r\n    this.raf = requestAnimationFrame(() => {\r\n        this.rafTimes += 1;\r\n        if (this.rafTimes >= 20) {\r\n            this.scrollBody(); // 触发实际滚动方法\r\n            this.rafTimes = 0;\r\n        } else {\r\n            this.setRaf();\r\n        }\r\n    });\r\n},\r\nonScroll() {\r\n    if (requestAnimationFrame) {\r\n        this.rafTimes = 0;\r\n        cancelAnimationFrame(this.raf);\r\n        this.setRaf();\r\n    } else {\r\n        this.scrollBody(); // 触发实际滚动方法\r\n    }\r\n},\r\n```\r\n\r\n由于 `requestAnimationFrame` 存在兼容性问题，首先需要进行一下判断：\r\n\r\n```javascript\r\nconst requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame;\r\nconst cancelAnimationFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame;\r\n```\r\n\r\n最好的方式应该是要对 `requestAnimationFrame` 进行 `polyfill` 的，但是 `requestAnimationFrame` 的 `polyfill` 会用到` setTimeout` ，还是会延时，所以在不支持 `requestAnimationFrame` 的环境下只能不做防抖了。\r\n\r\n### 求助\r\n\r\n如果有谁知道这是为什么的，一定一定要告诉我 ~ 谢谢 ~\r\n\r\n\r\n"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/24",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/24/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/24/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/24/events",
    "html_url": "https://github.com/axuebin/articles/issues/24",
    "id": 271478192,
    "node_id": "MDU6SXNzdWUyNzE0NzgxOTI=",
    "number": 24,
    "title": "JavaScript基础心法——数组",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "node_id": "MDQ6VXNlcjEzMzE2Mzky",
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720883997,
        "node_id": "MDU6TGFiZWw3MjA4ODM5OTc=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/ES6",
        "name": "ES6",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884127,
        "node_id": "MDU6TGFiZWw3MjA4ODQxMjc=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 724512309,
        "node_id": "MDU6TGFiZWw3MjQ1MTIzMDk=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/writing",
        "name": "writing",
        "color": "c5def5",
        "default": false
      },
      {
        "id": 720884524,
        "node_id": "MDU6TGFiZWw3MjA4ODQ1MjQ=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%89%8D%E7%AB%AF",
        "name": "前端",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-11-06T13:39:35Z",
    "updated_at": "2017-11-06T13:39:35Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "> 占坑 "
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/20",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/20/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/20/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/20/events",
    "html_url": "https://github.com/axuebin/articles/issues/20",
    "id": 269268127,
    "node_id": "MDU6SXNzdWUyNjkyNjgxMjc=",
    "number": 20,
    "title": "JavaScript基础心法——深浅拷贝",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "node_id": "MDQ6VXNlcjEzMzE2Mzky",
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720884127,
        "node_id": "MDU6TGFiZWw3MjA4ODQxMjc=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720882955,
        "node_id": "MDU6TGFiZWw3MjA4ODI5NTU=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 720884524,
        "node_id": "MDU6TGFiZWw3MjA4ODQ1MjQ=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%89%8D%E7%AB%AF",
        "name": "前端",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 4,
    "created_at": "2017-10-28T00:15:14Z",
    "updated_at": "2018-07-25T09:58:55Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "浅拷贝和深拷贝都是对于JS中的引用类型而言的，浅拷贝就只是复制对象的引用，如果拷贝后的对象发生变化，原对象也会发生变化。只有深拷贝才是真正地对对象的拷贝。\r\n\r\n----\r\n\r\n## 前言\r\n\r\n说到深浅拷贝，必须先提到的是JavaScript的数据类型，之前的一篇文章[JavaScript基础心法——数据类型](https://github.com/axuebin/articles/issues/3)说的很清楚了，这里就不多说了。\r\n\r\n需要知道的就是一点：JavaScript的数据类型分为基本数据类型和引用数据类型。\r\n\r\n对于基本数据类型的拷贝，并没有深浅拷贝的区别，我们所说的深浅拷贝都是对于引用数据类型而言的。\r\n\r\n## 浅拷贝\r\n\r\n浅拷贝的意思就是只复制引用，而未复制真正的值。\r\n\r\n```javascript\r\nconst originArray = [1,2,3,4,5];\r\nconst originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};\r\n\r\nconst cloneArray = originArray;\r\nconst cloneObj = originObj;\r\n\r\nconsole.log(cloneArray); // [1,2,3,4,5]\r\nconsole.log(originObj); // {a:'a',b:'b',c:Array[3],d:{dd:'dd'}}\r\n\r\ncloneArray.push(6);\r\ncloneObj.a = {aa:'aa'};\r\n\r\nconsole.log(cloneArray); // [1,2,3,4,5,6]\r\nconsole.log(originArray); // [1,2,3,4,5,6]\r\n\r\nconsole.log(cloneObj); // {a:{aa:'aa'},b:'b',c:Array[3],d:{dd:'dd'}}\r\nconsole.log(originArray); // {a:{aa:'aa'},b:'b',c:Array[3],d:{dd:'dd'}}\r\n```\r\n\r\n上面的代码是最简单的利用 `=` 赋值操作符实现了一个浅拷贝，可以很清楚的看到，随着 `cloneArray` 和 `cloneObj` 改变，`originArray` 和 `originObj` 也随着发生了变化。\r\n\r\n## 深拷贝\r\n\r\n深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。\r\n\r\n只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。\r\n\r\n目前实现深拷贝的方法不多，主要是两种：\r\n\r\n1. 利用 `JSON` 对象中的 `parse` 和 `stringify`\r\n2. 利用递归来实现每一层都重新创建对象并赋值\r\n\r\n### JSON.stringify/parse的方法\r\n\r\n先看看这两个方法吧：\r\n\r\n> The JSON.stringify() method converts a JavaScript value to a JSON string.\r\n\r\n`JSON.stringify` 是将一个 `JavaScript` 值转成一个 `JSON` 字符串。\r\n\r\n> The JSON.parse() method parses a JSON string, constructing the JavaScript value or object described by the string.\r\n\r\n`JSON.parse` 是将一个 `JSON` 字符串转成一个 `JavaScript` 值或对象。\r\n\r\n很好理解吧，就是 `JavaScript` 值和 `JSON` 字符串的相互转换。\r\n\r\n它能实现深拷贝呢？我们来试试。\r\n\r\n```javascript\r\nconst originArray = [1,2,3,4,5];\r\nconst cloneArray = JSON.parse(JSON.stringify(originArray));\r\nconsole.log(cloneArray === originArray); // false\r\n\r\nconst originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};\r\nconst cloneObj = JSON.parse(JSON.stringify(originObj));\r\nconsole.log(cloneObj === originObj); // false\r\n\r\ncloneObj.a = 'aa';\r\ncloneObj.c = [1,1,1];\r\ncloneObj.d.dd = 'doubled';\r\n\r\nconsole.log(cloneObj); // {a:'aa',b:'b',c:[1,1,1],d:{dd:'doubled'}};\r\nconsole.log(originObj); // {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};\r\n```\r\n\r\n确实是深拷贝，也很方便。但是，这个方法只能适用于一些简单的情况。比如下面这样的一个对象就不适用：\r\n\r\n```javascript\r\nconst originObj = {\r\n  name:'axuebin',\r\n  sayHello:function(){\r\n    console.log('Hello World');\r\n  }\r\n}\r\nconsole.log(originObj); // {name: \"axuebin\", sayHello: ƒ}\r\nconst cloneObj = JSON.parse(JSON.stringify(originObj));\r\nconsole.log(cloneObj); // {name: \"axuebin\"}\r\n```\r\n\r\n发现在 `cloneObj` 中，有属性丢失了。。。那是为什么呢？\r\n\r\n在 `MDN` 上找到了原因：\r\n\r\n>If undefined, a function, or a symbol is encountered during conversion it is either omitted (when it is found in an object) or censored to null (when it is found in an array). JSON.stringify can also just return undefined when passing in \"pure\" values like JSON.stringify(function(){}) or JSON.stringify(undefined).\r\n\r\n`undefined`、`function`、`symbol` 会在转换过程中被忽略。。。\r\n\r\n明白了吧，就是说如果对象中含有一个函数时（很常见），就不能用这个方法进行深拷贝。\r\n\r\n### 递归的方法\r\n\r\n递归的思想就很简单了，就是对每一层的数据都实现一次 `创建对象->对象赋值` 的操作，简单粗暴上代码：\r\n\r\n```javascript\r\nfunction deepClone(source){\r\n  const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象\r\n  for(let keys in source){ // 遍历目标\r\n    if(source.hasOwnProperty(keys)){\r\n      if(source[keys] && typeof source[keys] === 'object'){ // 如果值是对象，就递归一下\r\n        targetObj[keys] = source[keys].constructor === Array ? [] : {};\r\n        targetObj[keys] = deepClone(source[keys]);\r\n      }else{ // 如果不是，就直接赋值\r\n        targetObj[keys] = source[keys];\r\n      }\r\n    } \r\n  }\r\n  return targetObj;\r\n}\r\n```\r\n\r\n我们来试试：\r\n\r\n```javascript\r\nconst originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};\r\nconst cloneObj = deepClone(originObj);\r\nconsole.log(cloneObj === originObj); // false\r\n\r\ncloneObj.a = 'aa';\r\ncloneObj.c = [1,1,1];\r\ncloneObj.d.dd = 'doubled';\r\n\r\nconsole.log(cloneObj); // {a:'aa',b:'b',c:[1,1,1],d:{dd:'doubled'}};\r\nconsole.log(originObj); // {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};\r\n```\r\n\r\n可以。那再试试带有函数的：\r\n\r\n```javascript\r\nconst originObj = {\r\n  name:'axuebin',\r\n  sayHello:function(){\r\n    console.log('Hello World');\r\n  }\r\n}\r\nconsole.log(originObj); // {name: \"axuebin\", sayHello: ƒ}\r\nconst cloneObj = deepClone(originObj);\r\nconsole.log(cloneObj); // {name: \"axuebin\", sayHello: ƒ}\r\n```\r\n\r\n也可以。搞定。\r\n\r\n是不是以为这样就完了？？ 当然不是。\r\n\r\n## JavaScript中的拷贝方法\r\n\r\n我们知道在 `JavaScript` 中，数组有两个方法 `concat` 和 `slice` 是可以实现对原数组的拷贝的，这两个方法都不会修改原数组，而是返回一个修改后的新数组。\r\n\r\n同时，ES6 中 引入了 `Object.assgn` 方法和 `...` 展开运算符也能实现对对象的拷贝。\r\n \r\n那它们是浅拷贝还是深拷贝呢？\r\n\r\n### concat\r\n\r\n> The concat() method is used to merge two or more arrays. This method does not change the existing arrays, but instead returns a new array.\r\n\r\n该方法可以连接两个或者更多的数组，但是它不会修改已存在的数组，而是返回一个新数组。\r\n\r\n看着这意思，很像是深拷贝啊，我们来试试：\r\n\r\n```javascript\r\nconst originArray = [1,2,3,4,5];\r\nconst cloneArray = originArray.concat();\r\n\r\nconsole.log(cloneArray === originArray); // false\r\ncloneArray.push(6); // [1,2,3,4,5,6]\r\nconsole.log(originArray); [1,2,3,4,5];\r\n```\r\n\r\n看上去是深拷贝的。\r\n\r\n我们来考虑一个问题，如果这个对象是多层的，会怎样。\r\n\r\n```javascript\r\nconst originArray = [1,[1,2,3],{a:1}];\r\nconst cloneArray = originArray.concat();\r\nconsole.log(cloneArray === originArray); // false\r\ncloneArray[1].push(4);\r\ncloneArray[2].a = 2; \r\nconsole.log(originArray); // [1,[1,2,3,4],{a:2}]\r\n```\r\n\r\n`originArray` 中含有数组 `[1,2,3]` 和对象 `{a:1}`，如果我们直接修改数组和对象，不会影响 `originArray`，但是我们修改数组 `[1,2,3]` 或对象 `{a:1}` 时，发现 `originArray` 也发生了变化。 \r\n\r\n**结论：`concat` 只是对数组的第一层进行深拷贝。**\r\n\r\n### slice\r\n\r\n> The slice() method returns a shallow copy of a portion of an array into a new array object selected from begin to end (end not included). The original array will not be modified.\r\n\r\n解释中都直接写道是 `a shallow copy` 了 ~\r\n\r\n但是，并不是！\r\n\r\n```javascript\r\nconst originArray = [1,2,3,4,5];\r\nconst cloneArray = originArray.slice();\r\n\r\nconsole.log(cloneArray === originArray); // false\r\ncloneArray.push(6); // [1,2,3,4,5,6]\r\nconsole.log(originArray); [1,2,3,4,5];\r\n```\r\n\r\n同样地，我们试试多层的数组。\r\n\r\n```javascript\r\nconst originArray = [1,[1,2,3],{a:1}];\r\nconst cloneArray = originArray.slice();\r\nconsole.log(cloneArray === originArray); // false\r\ncloneArray[1].push(4);\r\ncloneArray[2].a = 2; \r\nconsole.log(originArray); // [1,[1,2,3,4],{a:2}]\r\n```\r\n\r\n果然，结果和 `concat` 是一样的。\r\n\r\n**结论：`slice` 只是对数组的第一层进行深拷贝。**\r\n\r\n### Object.assign()\r\n\r\n> The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object. It will return the target object.\r\n\r\n复制复制复制。\r\n\r\n那到底是浅拷贝还是深拷贝呢？\r\n\r\n自己试试吧。。\r\n\r\n**结论：`Object.assign()` 拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。**\r\n\r\n### ... 展开运算符\r\n\r\n```javascript\r\nconst originArray = [1,2,3,4,5,[6,7,8]];\r\nconst originObj = {a:1,b:{bb:1}};\r\n\r\nconst cloneArray = [...originArray];\r\ncloneArray[0] = 0;\r\ncloneArray[5].push(9);\r\nconsole.log(originArray); // [1,2,3,4,5,[6,7,8,9]]\r\n\r\nconst cloneObj = {...originObj};\r\ncloneObj.a = 2;\r\ncloneObj.b.bb = 2;\r\nconsole.log(originObj); // {a:1,b:{bb:2}}\r\n```\r\n\r\n**结论：`...` 实现的是对象第一层的深拷贝。后面的只是拷贝的引用值。**\r\n\r\n\r\n### 首层浅拷贝\r\n\r\n我们知道了，会有一种情况，就是对目标对象的第一层进行深拷贝，然后后面的是浅拷贝，可以称作“首层浅拷贝”。\r\n\r\n我们可以自己实现一个这样的函数：\r\n\r\n```javascript\r\nfunction shallowClone(source) {\r\n  const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象\r\n  for (let keys in source) { // 遍历目标\r\n    if (source.hasOwnProperty(keys)) {\r\n      targetObj[keys] = source[keys];\r\n    }\r\n  }\r\n  return targetObj;\r\n}\r\n```\r\n\r\n我们来测试一下：\r\n\r\n```javascript\r\nconst originObj = {a:'a',b:'b',c:[1,2,3],d:{dd:'dd'}};\r\nconst cloneObj = shallowClone(originObj);\r\nconsole.log(cloneObj === originObj); // false\r\ncloneObj.a='aa';\r\ncloneObj.c=[1,1,1];\r\ncloneObj.d.dd='surprise';\r\n```\r\n\r\n经过上面的修改，`cloneObj` 不用说，肯定是 `{a:'aa',b:'b',c:[1,1,1],d:{dd:'surprise'}}` 了，那 `originObj` 呢？刚刚我们验证了 `cloneObj === originObj` 是 `false`，说明这两个对象引用地址不同啊，那应该就是修改了 `cloneObj` 并不影响 `originObj`。\r\n\r\n```javascript\r\nconsole.log(cloneObj); // {a:'aa',b:'b',c:[1,1,1],d:{dd:'surprise'}}\r\nconsole.log(originObj); // {a:'a',b:'b',c:[1,2,3],d:{dd:'surprise'}}\r\n```\r\n\r\nWhat happend?\r\n\r\n`originObj` 中关于 `a`、`c`都没被影响，但是 `d` 中的一个对象被修改了。。。说好的深拷贝呢？不是引用地址都不一样了吗？\r\n\r\n原来是这样：\r\n\r\n1. 从 `shallowClone` 的代码中我们可以看出，我们只对第一层的目标进行了 `深拷贝` ，而第二层开始的目标我们是直接利用 `=` 赋值操作符进行拷贝的。\r\n2. so，第二层后的目标都只是复制了一个引用，也就是浅拷贝。\r\n\r\n## 总结\r\n\r\n1. 赋值运算符 `=` 实现的是浅拷贝，只拷贝对象的引用值；\r\n2. JavaScript 中数组和对象自带的拷贝方法都是“首层浅拷贝”；\r\n3. `JSON.stringify` 实现的是深拷贝，但是对目标对象有要求；\r\n4. 若想真正意义上的深拷贝，请递归。"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/18",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/18/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/18/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/18/events",
    "html_url": "https://github.com/axuebin/articles/issues/18",
    "id": 268649998,
    "node_id": "MDU6SXNzdWUyNjg2NDk5OTg=",
    "number": 18,
    "title": "JavaScript基础心法——跨域",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "node_id": "MDQ6VXNlcjEzMzE2Mzky",
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720884127,
        "node_id": "MDU6TGFiZWw3MjA4ODQxMjc=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 724512309,
        "node_id": "MDU6TGFiZWw3MjQ1MTIzMDk=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/writing",
        "name": "writing",
        "color": "c5def5",
        "default": false
      },
      {
        "id": 720884524,
        "node_id": "MDU6TGFiZWw3MjA4ODQ1MjQ=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%89%8D%E7%AB%AF",
        "name": "前端",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-10-26T07:04:02Z",
    "updated_at": "2017-10-26T07:04:32Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "> todo"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/17",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/17/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/17/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/17/events",
    "html_url": "https://github.com/axuebin/articles/issues/17",
    "id": 268646072,
    "node_id": "MDU6SXNzdWUyNjg2NDYwNzI=",
    "number": 17,
    "title": "JavaScript基础心法——闭包",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "node_id": "MDQ6VXNlcjEzMzE2Mzky",
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720884127,
        "node_id": "MDU6TGFiZWw3MjA4ODQxMjc=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 724512309,
        "node_id": "MDU6TGFiZWw3MjQ1MTIzMDk=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/writing",
        "name": "writing",
        "color": "c5def5",
        "default": false
      },
      {
        "id": 720884524,
        "node_id": "MDU6TGFiZWw3MjA4ODQ1MjQ=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%89%8D%E7%AB%AF",
        "name": "前端",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-10-26T06:43:58Z",
    "updated_at": "2017-10-26T07:04:45Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "> todo"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/16",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/16/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/16/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/16/events",
    "html_url": "https://github.com/axuebin/articles/issues/16",
    "id": 268646010,
    "node_id": "MDU6SXNzdWUyNjg2NDYwMTA=",
    "number": 16,
    "title": "JavaScript基础心法——继承",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "node_id": "MDQ6VXNlcjEzMzE2Mzky",
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720884127,
        "node_id": "MDU6TGFiZWw3MjA4ODQxMjc=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 724512309,
        "node_id": "MDU6TGFiZWw3MjQ1MTIzMDk=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/writing",
        "name": "writing",
        "color": "c5def5",
        "default": false
      },
      {
        "id": 720884524,
        "node_id": "MDU6TGFiZWw3MjA4ODQ1MjQ=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%89%8D%E7%AB%AF",
        "name": "前端",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-10-26T06:43:39Z",
    "updated_at": "2017-10-26T06:43:39Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "基础最重要。\r\n\r\n> todo"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/15",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/15/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/15/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/15/events",
    "html_url": "https://github.com/axuebin/articles/issues/15",
    "id": 268294839,
    "node_id": "MDU6SXNzdWUyNjgyOTQ4Mzk=",
    "number": 15,
    "title": "一个关于数组循环嵌套的性能问题",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "node_id": "MDQ6VXNlcjEzMzE2Mzky",
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720881366,
        "node_id": "MDU6TGFiZWw3MjA4ODEzNjY=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/help%20wanted",
        "name": "help wanted",
        "color": "33aa3f",
        "default": true
      },
      {
        "id": 724512309,
        "node_id": "MDU6TGFiZWw3MjQ1MTIzMDk=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/writing",
        "name": "writing",
        "color": "c5def5",
        "default": false
      },
      {
        "id": 723280030,
        "node_id": "MDU6TGFiZWw3MjMyODAwMzA=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95",
        "name": "数据结构及算法",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-10-25T07:35:08Z",
    "updated_at": "2017-11-02T06:14:55Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "应该是有两个数组，它们的长度不同。\r\n\r\n```javascript\r\nconst a = 500000;\r\nconst b = 1000;\r\nfor(let i=0;i<a;i++){\r\n  for(let j=0;j<b;j++){\r\n  }\r\n}\r\nfor(let i=0;i<b;i++){\r\n  for(let j=0;j<a;j++){\r\n  }\r\n}\r\n```\r\n\r\n关于上述两种循环嵌套的方式，哪种效率更好？\r\n\r\n经过测试，是先小后大的效率更好，为什么？\r\n\r\n>todo"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/14",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/14/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/14/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/14/events",
    "html_url": "https://github.com/axuebin/articles/issues/14",
    "id": 267869833,
    "node_id": "MDU6SXNzdWUyNjc4Njk4MzM=",
    "number": 14,
    "title": "Babel将ES6代码转换成什么样了？",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "node_id": "MDQ6VXNlcjEzMzE2Mzky",
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720883997,
        "node_id": "MDU6TGFiZWw3MjA4ODM5OTc=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/ES6",
        "name": "ES6",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720884127,
        "node_id": "MDU6TGFiZWw3MjA4ODQxMjc=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 724512309,
        "node_id": "MDU6TGFiZWw3MjQ1MTIzMDk=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/writing",
        "name": "writing",
        "color": "c5def5",
        "default": false
      },
      {
        "id": 720884524,
        "node_id": "MDU6TGFiZWw3MjA4ODQ1MjQ=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E5%89%8D%E7%AB%AF",
        "name": "前端",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-10-24T01:41:00Z",
    "updated_at": "2017-10-26T06:05:59Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "> todo\r\n\r\nBabel官方工具：[https://babeljs.io/repl/](https://babeljs.io/repl/)"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/13",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/13/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/13/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/13/events",
    "html_url": "https://github.com/axuebin/articles/issues/13",
    "id": 267470869,
    "node_id": "MDU6SXNzdWUyNjc0NzA4Njk=",
    "number": 13,
    "title": "JavaScript数据结构及算法——查找",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "node_id": "MDQ6VXNlcjEzMzE2Mzky",
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720884127,
        "node_id": "MDU6TGFiZWw3MjA4ODQxMjc=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720882955,
        "node_id": "MDU6TGFiZWw3MjA4ODI5NTU=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 723280030,
        "node_id": "MDU6TGFiZWw3MjMyODAwMzA=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95",
        "name": "数据结构及算法",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-10-22T14:48:15Z",
    "updated_at": "2017-10-30T09:12:34Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "本文主要记录的是JavaScript实现常用的查找算法。\r\n\r\n----\r\n\r\n## 前言\r\n\r\n用JavaScript写算法是种怎么样的体验？不喜欢算法的我最近也对数据结构和算法有点兴趣。。。所以，将会有这些：\r\n\r\n- JavaScript数据结构及算法——栈\r\n- JavaScript数据结构及算法——队列\r\n- JavaScript数据结构及算法——链表\r\n- [JavaScript数据结构及算法——排序](https://github.com/axuebin/articles/issues/12)\r\n- [JavaScript数据结构及算法——查找](https://github.com/axuebin/articles/issues/13)\r\n- JavaScript数据结构及算法——树\r\n\r\n现阶段我对于数据结构、算法的理解还很浅，希望各位大佬多多指导。\r\n\r\n## 查找\r\n\r\n> 查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介绍了常见的七种查找算法，说是七种，其实二分查找、插值查找以及斐波那契查找都可以归为一类——插值查找。插值查找和斐波那契查找是在二分查找的基础上的优化查找算法。\r\n\r\n这里主要提到如何用JavaScript实现顺序查找和二分查找。\r\n\r\n## 顺序查找\r\n\r\n**主要思想**：将每一个数据结构中的元素和要查找的元素做比较，类似于JavaScript中indexOf\r\n\r\n**时间复杂度**：O(n)\r\n\r\n代码：\r\n\r\n```javascript\r\nfunction sequentialSearch(array,item){\r\n  for (let i = 0; i < array.length; i += 1) {\r\n    if ( item === array[i] ) {\r\n      return i;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n```\r\n\r\n比如我现在有这样一个数组 `[5, 4, 3, 2, 1]` ，然后我们需要在其中找到 `3` ，整个流程应该是这样：\r\n\r\n```javascript\r\n[5, 4, 3, 2, 1] // 5 !== 3，继续遍历\r\n[5, 4, 3, 2, 1] // 4 !== 3，继续遍历\r\n[5, 4, 3, 2, 1] // 3 === 3，找到了\r\n```\r\n\r\n## 二分查找\r\n\r\n**主要思想**：首先这个数组是排好序的，然后将数组一直二分缩小范围，直到找到为止。\r\n\r\n**时间复杂度**：O(logn)\r\n\r\n代码：\r\n\r\n```javascript\r\nfunction binarySearch(array, item) {\r\n  const sortArray = quickSort(array); // 对数组进行快排\r\n  let low = 0; // 设置左边界\r\n  let high = sortArray.length - 1; // 设置右边界\r\n  let mid = 0; // 设置中间值\r\n  let element = 0;\r\n  while (low < high) {\r\n    mid = Math.floor((low + high) / 2); // 选择整个数组的中间值\r\n    element = sortArray[mid];\r\n    if (element < item) { // 如果待搜索值比选中值要大，则返回步骤一在右边的字数组中寻找\r\n      low = mid + 1;\r\n    } else if (element > item) { // 如果待搜索值比选中值要小，则返回步骤一在左边的字数组中寻找\r\n      high = mid - 1;\r\n    } else {\r\n      return mid; // 如果刚好选中，恭喜你，直接返回\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n```"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/12",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/12/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/12/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/12/events",
    "html_url": "https://github.com/axuebin/articles/issues/12",
    "id": 267380423,
    "node_id": "MDU6SXNzdWUyNjczODA0MjM=",
    "number": 12,
    "title": "JavaScript数据结构及算法——排序",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "node_id": "MDQ6VXNlcjEzMzE2Mzky",
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720884127,
        "node_id": "MDU6TGFiZWw3MjA4ODQxMjc=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/JavaScript",
        "name": "JavaScript",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 720882955,
        "node_id": "MDU6TGFiZWw3MjA4ODI5NTU=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 723280030,
        "node_id": "MDU6TGFiZWw3MjMyODAwMzA=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95",
        "name": "数据结构及算法",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 0,
    "created_at": "2017-10-21T13:33:03Z",
    "updated_at": "2017-10-30T01:58:43Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "本文主要记录的是JavaScript实现常用的排序算法，冒泡排序、快速排序、归并排序等。\r\n\r\n----\r\n\r\n## 前言\r\n\r\n用JavaScript写算法是种怎么样的体验？不喜欢算法的我最近也对数据结构和算法有点兴趣。。。所以，将会有这些：\r\n\r\n- JavaScript数据结构及算法——栈\r\n- JavaScript数据结构及算法——队列\r\n- JavaScript数据结构及算法——链表\r\n- [JavaScript数据结构及算法——排序](https://github.com/axuebin/articles/issues/12)\r\n- [JavaScript数据结构及算法——查找](https://github.com/axuebin/articles/issues/13)\r\n- JavaScript数据结构及算法——树\r\n\r\n现阶段我对于数据结构、算法的理解还很浅，希望各位大佬多多指导。\r\n\r\n## 排序\r\n\r\n> 介绍排序算法\r\n\r\n## 冒泡排序\r\n\r\n说到冒泡排序，大家都很熟悉，顾名思义，是一种“冒泡”的过程。\r\n\r\n**主要思想**：比较任何两个相邻的项，如果第一个比第二个大，则交换它们。\r\n\r\n**时间复杂度**：O(n2)\r\n\r\n**空间复杂度**：O(1)\r\n\r\n如何实现呢？是不是遍历所有需要排序的数据，然后将它和所有数比较一次，然后就可以了？\r\n\r\n道理是有的，我们试试看：\r\n\r\n```javascript\r\nfunction bubbleSort(arr) {\r\n  const len = arr.length; // 声明一个len来存储数组的长度\r\n  let temp = 0;\r\n  for (let i = 0; i < len; i += 1) { // 外循环遍历数组\r\n    for (let j = 0 ; j < len - 1 ; j += 1) { // 内循环执行当前项和下一项进行比较\r\n      if (arr[j] > arr[j + 1]) {  // 如果当前项比下一项大，则交换它们\r\n        temp = arr[j];\r\n        arr[j] = arr[j + 1];\r\n        arr[j + 1] = temp;\r\n      }\r\n      console.log(arr);\r\n    }\r\n  }\r\n  return arr;\r\n}\r\n```\r\n\r\n我们通过输出数组来看一下整个流程：\r\n\r\n```javascript\r\n[5, 4, 3, 2, 1] \r\n[4, 5, 3, 2, 1] // 5>4，交换\r\n[4, 3, 5, 2, 1] // 5>3，交换\r\n[4, 3, 2, 5, 1] // 5>2，交换\r\n[4, 3, 2, 1, 5] // 5>1，交换\r\n[3, 4, 2, 1, 5] // 4>3，交换\r\n[3, 2, 4, 1, 5] // 4>2，交换\r\n[3, 2, 1, 4, 5] // 4>1，交换\r\n[3, 2, 1, 4, 5] // 4<5，不交换\r\n[2, 3, 1, 4, 5] // 3>2，交换\r\n[2, 1, 3, 4, 5] // 3>1，交换\r\n[2, 1, 3, 4, 5] // 3<4，不交换\r\n[2, 1, 3, 4, 5] // 4<5，不交换\r\n[1, 2, 3, 4, 5] // 2>1，交换\r\n[1, 2, 3, 4, 5] // 2<3，不交换\r\n[1, 2, 3, 4, 5] // 3<4，不交换\r\n[1, 2, 3, 4, 5] // 4<5，不交换\r\n[1, 2, 3, 4, 5] // 1<2，不交换\r\n[1, 2, 3, 4, 5] // 2<3，不交换\r\n[1, 2, 3, 4, 5] // 3<4，不交换\r\n[1, 2, 3, 4, 5] // 4<5，不交换\r\n```\r\n\r\n排序确实是排好了，但是我们发现，有很多的不必要的比较，我们应该想办法避免这些。想一想，这些都是在内循环中对已经排序过的数进行比较，所以我们可以稍稍改进一下代码：\r\n\r\n```javascript\r\nfunction bubbleSort(arr) {\r\n  const len = arr.length;\r\n  let temp = 0;\r\n  for (let i = 0; i < len; i += 1) {\r\n    for (let j = 0 ; j < len - 1 - i ; j += 1) {\r\n      if (arr[j] > arr[j + 1]) {\r\n        temp = arr[j];\r\n        arr[j] = arr[j + 1];\r\n        arr[j + 1] = temp;\r\n      }\r\n      console.log(arr);\r\n    }\r\n  }\r\n  return arr;\r\n}\r\n```\r\n\r\n在内循环中，我们另 `j` 的取值到 `len-1-i` 为止，因为再往后的数已经排序好了。同样地，我们来看看流程：\r\n\r\n```javascript\r\n[5, 4, 3, 2, 1] \r\n[4, 5, 3, 2, 1] // 5>4，交换\r\n[4, 3, 5, 2, 1] // 5>3，交换\r\n[4, 3, 2, 5, 1] // 5>2，交换\r\n[4, 3, 2, 1, 5] // 5>1，交换\r\n[3, 4, 2, 1, 5] // 4>3，交换\r\n[3, 2, 4, 1, 5] // 4>2，交换\r\n[3, 2, 1, 4, 5] // 4>1，交换\r\n[2, 3, 1, 4, 5] // 3>2，交换\r\n[2, 1, 3, 4, 5] // 3>1，交换\r\n[1, 2, 3, 4, 5] // 2>1，交换\r\n```\r\n\r\nnice，没必要的比较已经完全没有了。\r\n\r\n## 选择排序\r\n\r\n**主要思想**：找到数组中的最小值然后将其放置在第一位，接着第二位第三位。。。\r\n\r\n**时间复杂度**：O(n2)\r\n\r\n**空间复杂度**：O(1)\r\n\r\n直接看代码吧：\r\n\r\n```javascript\r\nfunction selectionSort(arr) {\r\n  const len = arr.length; // 用len存储数组长度\r\n  let indexMin = 0; // 最小值索引\r\n  let temp = 0;\r\n  for (let i = 0; i < len - 1; i += 1) { //外循环遍历数组\r\n    indexMin = i; // 先假设这一轮循环的第一个值是最小的\r\n    for (let j = i; j < len; j += 1) { // 比较i时候会比它之后的数小，如果小，则令indexMin存储这个更小值的索引\r\n       if (arr[indexMin] > arr[j]) {\r\n        indexMin = j;\r\n      }\r\n    }\r\n    if (i !== indexMin) { // 执行完内循环之后判断当前值i是否是最小的，如果不是，就要交换\r\n      temp = arr[i];\r\n      arr[i] = arr[indexMin];\r\n      arr[indexMin] = temp;\r\n    }\r\n    console.log(arr);\r\n  }\r\n  return arr;\r\n}\r\n```\r\n\r\n```javascript\r\n[5, 4, 3, 2, 1] \r\n[1, 4, 3, 2, 5] // 寻找最小值1，交换1和5\r\n[1, 2, 3, 4, 5] // 寻找最小值2，交换2和4\r\n[1, 2, 3, 4, 5] // 寻找最小值3，不交换\r\n[1, 2, 3, 4, 5] // 寻找最小值4，不交换\r\n[1, 2, 3, 4, 5] // 寻找最小值5，不交换\r\n```\r\n\r\n是不是很酷，然而它的时间复杂度其实还是 `O(n2)`。\r\n\r\n## 插入排序\r\n\r\n**主要思想**：每次将一个元素与已排序的元素进行逐一比较，直到找到合适的位置按大小插入。\r\n\r\n**时间复杂度**：O(n2)\r\n\r\n**空间复杂度**：O(1)\r\n\r\n直接看代码吧：\r\n\r\n```javascript\r\nfunction insertionSort(arr) {\r\n  const len = arr.length; // 数组长度\r\n  let j = 0; // 使用的辅助变量\r\n  let temp = 0;\r\n  for (let i = 1; i < len; i++) { // 外循环，从1开始\r\n    j = i; // 当前索引赋给j\r\n    temp = arr[i]; // 当前值存在temp\r\n    while (j > 0 && arr[j - 1] > temp) { // 如果j前面的数比它大，就往前移，直到第一位\r\n      arry[j] = arr[j - 1];\r\n      j--;\r\n    }\r\n    arr[j] = temp; // temp是要排序的那个数，放到正确的j的位置上\r\n  }\r\n  return arr;\r\n}\r\n```\r\n\r\n## 归并排序\r\n\r\n**主要思想**：思想主要是分治。将原始数组划分成较小的数组，直到每个小数组只有一个位置，然后将小数组归并成较大的数组。\r\n\r\n**时间复杂度**：O(nlogn)\r\n\r\n**空间复杂度**：O(n)\r\n\r\n直接看代码吧：\r\n\r\n```javascript\r\n// 分\r\nfunction mergeSort(arr) {\r\n  const len = arr.length;\r\n  if (len === 1) {\r\n    return arr;\r\n  }\r\n  const mid = Math.floor(len / 2);\r\n  const left = arr.slice(0, mid);\r\n  const right = arr.slice(mid, len);\r\n  return merge(mergeSort(left), mergeSort(right));\r\n}\r\n \r\n// 合\r\nfunction merge(left, right) {\r\n  const result = [];\r\n  let il = 0;\r\n  let ir = 0;\r\n  while (il < left.length && ir < right.length) {\r\n    if (left[il] < right[ir]) {\r\n      result.push(left[il++]);\r\n    } else {\r\n      result.push(right[ir++]);\r\n    }\r\n  }\r\n  while (il < left.length) {\r\n    result.push(left[il++]);\r\n  }\r\n  while (ir < right.length) {\r\n    result.push(right[ir++]);\r\n  }\r\n  return result;\r\n}\r\n```\r\n\r\n## 快速排序\r\n\r\n来看看面试中最喜欢考察的快速排序。\r\n\r\n**主要思想**：每次将一个元素与已排序的元素进行逐一比较，直到找到合适的位置按大小插入。\r\n\r\n**时间复杂度**：O(nlogn)\r\n\r\n**空间复杂度**：O(logn)\r\n\r\n```javascript\r\nfunction quickSort(arr) {\r\n  if (arr.length <= 1) {\r\n    return arr;\r\n  }\r\n  const pivotIndex = Math.floor(arr.length / 2);\r\n  const pivot = arr.splice(pivotIndex, 1)[0]; // 将这个元素取出并从原数组中删除\r\n  const left = [];\r\n  const right = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    if (arr[i] < pivot) {\r\n      left.push(arr[i]);\r\n    } else {\r\n      right.push(arr[i]);\r\n    }\r\n  }\r\n  return quickSort(left).concat(pivot, quickSort(right));\r\n}\r\n```"
  },
  {
    "url": "https://api.github.com/repos/axuebin/articles/issues/10",
    "repository_url": "https://api.github.com/repos/axuebin/articles",
    "labels_url": "https://api.github.com/repos/axuebin/articles/issues/10/labels{/name}",
    "comments_url": "https://api.github.com/repos/axuebin/articles/issues/10/comments",
    "events_url": "https://api.github.com/repos/axuebin/articles/issues/10/events",
    "html_url": "https://github.com/axuebin/articles/issues/10",
    "id": 266367921,
    "node_id": "MDU6SXNzdWUyNjYzNjc5MjE=",
    "number": 10,
    "title": "关于浏览器缓存我知道多少",
    "user": {
      "login": "axuebin",
      "id": 13316392,
      "node_id": "MDQ6VXNlcjEzMzE2Mzky",
      "avatar_url": "https://avatars0.githubusercontent.com/u/13316392?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/axuebin",
      "html_url": "https://github.com/axuebin",
      "followers_url": "https://api.github.com/users/axuebin/followers",
      "following_url": "https://api.github.com/users/axuebin/following{/other_user}",
      "gists_url": "https://api.github.com/users/axuebin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/axuebin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/axuebin/subscriptions",
      "organizations_url": "https://api.github.com/users/axuebin/orgs",
      "repos_url": "https://api.github.com/users/axuebin/repos",
      "events_url": "https://api.github.com/users/axuebin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/axuebin/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 720882955,
        "node_id": "MDU6TGFiZWw3MjA4ODI5NTU=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/blog",
        "name": "blog",
        "color": "0052cc",
        "default": false
      },
      {
        "id": 725736399,
        "node_id": "MDU6TGFiZWw3MjU3MzYzOTk=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E7%BC%93%E5%AD%98",
        "name": "缓存",
        "color": "ff9900",
        "default": false
      },
      {
        "id": 723279884,
        "node_id": "MDU6TGFiZWw3MjMyNzk4ODQ=",
        "url": "https://api.github.com/repos/axuebin/articles/labels/%E7%BD%91%E7%BB%9C%E5%8F%8A%E6%B5%8F%E8%A7%88%E5%99%A8",
        "name": "网络及浏览器",
        "color": "d93f0b",
        "default": false
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [

    ],
    "milestone": null,
    "comments": 2,
    "created_at": "2017-10-18T05:56:12Z",
    "updated_at": "2017-10-30T03:25:13Z",
    "closed_at": null,
    "author_association": "OWNER",
    "body": "在前端开发中，我们在提到性能优化的时候总会提到一点：合理设置缓存。我们该如何从这方面入手来考虑提高网站性能呢？\r\n\r\n----\r\n\r\n### 前言\r\n\r\n我们都知道 HTML5 引入了应用程序缓存，可以在没有网络的情况下进行访问，同时，HTML5 还引入了 storage 本地存储。这些都属于应用缓存。\r\n\r\n本篇文章主要内容是和浏览器缓存相关的，也可以说是 HTTP 缓存。\r\n\r\n### 什么是浏览器缓存\r\n\r\nMDN 上是这样解释浏览器缓存的：\r\n\r\n> A browser cache holds all documents downloaded via HTTP by the user ... without requiring an additional trip to the server. \r\n\r\n意思就是，浏览器缓存保存着用户通过 `HTTP` 获取的所有资源，再下一次请求时可以避免重复向服务器发出多余的请求。\r\n\r\n通俗的说，就是在你访问过一次某个网站之后，这个站点的文字、图片等所有资源都被下载到本地了，下次再访问该网站时判断是否满足缓存条件，如果满足就不用再花费时间去等待资源的获取了。\r\n\r\n### 浏览器缓存的分类\r\n\r\n一般来说浏览器缓存可以分为两类：\r\n\r\n- 强缓存\r\n- 协商缓存（对比缓存）\r\n\r\n我们需要知道的是，浏览器在加载资源时，会先判断是否命中**强缓存**再验证是命中**协商缓存**。\r\n\r\n其它的的具体细节，稍后会展开来说。\r\n\r\n### 强缓存\r\n\r\n浏览器在加载资源时，会先根据本地缓存资源的 `header` 中的信息判断是否命中强缓存，如果命中则直接使用缓存中的资源不会再向服务器发送请求。\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/%E5%BC%BA%E7%BC%93%E5%AD%98.png)\r\n\r\n从图中可以看出，强缓存一般是这样一个流程：\r\n\r\n1. 查看 `header` 头中的 `Expire` 和 `Cache-control` 来判断是否满足规则；\r\n2. 如果满足规则，就返回缓存的数据；\r\n3. 如果不满足规则，就向服务器发送请求；\r\n4. 服务器返回数据；\r\n5. 将新数据存入缓存。\r\n\r\n所以我们主要就是关注 `Expire` 和 `Cache-control` 这两个字段。\r\n\r\n#### Expire\r\n\r\n同样地，我们看看MDN中如何解释这个字段：\r\n\r\n> The Expires header contains the date/time after which the response is considered stale.\r\n\r\n这个字段包含了一个时间，过了这个时间，响应将会失效。\r\n\r\n也就是说，`Expire` 这个字段表示缓存到期时间，我们来打开一个网站并查看 `Response Header` 看看这个字段：\r\n\r\n```\r\nExpires:Fri, 27 Oct 2017 07:55:30 GMT\r\n```\r\n\r\n可能在你查看这的时候发现时间不对啊，怎么都已经是过去了 ~ \r\n\r\n`GMT` 表示的是格林威治时间，和北京时间相差8小时。\r\n\r\n上面的这个时间表示的是 `2017年10月27日15:55:30`。\r\n\r\n通过设置 `Expire` 来设置缓存有一个致命缺点：\r\n\r\n可以看出，这个是个绝对时间，也就是说，如果我修改了客户端的本地时间，是不是就会导致判断缓存失效了呢。\r\n\r\n#### Cache-Control\r\n\r\n既然不能设置绝对时间，那我就设置个相对时间呗。\r\n\r\n在 `HTTP/1.1` 中，增加了一个字段 `Cache-Control` ，它包含一个 `max-age` 属性，该字段表示资源缓存的最大有效时间，这就是一个相对时间。\r\n\r\n```\r\nCache-Control:max-age=600\r\n```\r\n\r\n这个表示的就是最大有效时间是 `600s` ，对的，它的单位是秒。\r\n\r\n`Cache-Control` 除了 `max-age` 属性之外还有一些属性：\r\n\r\n- no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存。\r\n- no-store：禁止使用缓存，每一次都要重新请求数据。\r\n- public：默认设置。\r\n- private：不能被多用户共享。\r\n\r\n现在基本上都会同时设置 `Expire` 和 `Cache-Control` ，`Cache-Control` 的优先级别更高。\r\n\r\n### 协商缓存\r\n\r\n当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据请求头中的部分信息来判断是否命中缓存。如果命中，则返回 `304` ，告诉浏览器资源未更新，可使用本地的缓存。\r\n\r\n![](http://omufjr5bv.bkt.clouddn.com/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.png)\r\n\r\n从图中可以看出，协商缓存一般是这样一个流程：\r\n\r\n1. 把资源标识，比如 `If-Modify-Since` 或 `Etag` 发送到服务器，确认资源是否更新；\r\n2. 如果资源未更新，请求响应返回的http状态为 `304` 并且会显示一个 `Not Modified` 的字符串，告诉浏览器使用本地缓存;\r\n3. 如果资源已经更新，返回新的数据； \r\n4. 将新数据存入缓存。\r\n\r\n#### Last-Modified，If-Modified-Since\r\n\r\n浏览器第一次请求资源的时候，服务器返回的 `header` 上会带有一个 `Last-Modified` 字段，表示资源**最后修改**的时间。\r\n\r\n```\r\nLast-Modified: Fri, 27 Oct 2017 07:55:30 GMT\r\n```\r\n\r\n同样的，这是一个 `GMT` 的绝对时间。\r\n\r\n当浏览器再次请求该资源时，请求头中会带有一个 `If-Modified-Since` 字段，这个值是第一次请求返回的 `Last-Modified` 的值。服务器收到这个请求后，将 `If-Modified-Since` 和当前的 `Last-Modified` 进行对比。如果相等，则说明资源未修改，返回 `304`，浏览器使用本地缓存。\r\n\r\nwell，这个方法也是有缺点的：\r\n\r\n- 最小单位是秒。也就是说如果我短时间内资源发生了改变，`Last-Modified` 并不会发生变化；\r\n- 周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 `Last-Modified` 可不这样认为。\r\n\r\n所以，后来又引入一个 `Etag`。\r\n\r\n#### Etag\r\n\r\n`Etag` 一般是由文件内容 `hash` 生成的，也就是说它可以保证资源的唯一性，资源发生改变就会导致 `Etag` 发生改变。\r\n\r\n同样地，在浏览器第一次请求资源时，服务器会返回一个 `Etag` 标识。当再次请求该资源时， 会通过 `If-no-match` 字段将 `Etag` 发送回服务器，然后服务器进行比较，如果相等，则返回 `304` 表示未修改。\r\n\r\n**`Last-Modified` 和 `Etag` 是可以同时设置的，服务器会优先校验 `Etag`，如果 `Etag` 相等就会继续比对 `Last-Modified`，最后才会决定是否返回 `304`。 **\r\n\r\n### 总结\r\n\r\n当浏览器再次访问一个已经访问过的资源时，它会这样做：\r\n\r\n1. 看看是否命中强缓存，如果命中，就直接使用缓存了；\r\n2. 如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存；\r\n3. 如果命中协商缓存，服务器会返回 `304` 告诉浏览器使用本地缓存；\r\n4. 否则，返回最新的资源。"
  }
]
